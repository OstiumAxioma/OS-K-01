---
date: 2024-01-17
tags:
  - 计算机/算法
  - 计算机/算法/策略
  - 计算机
component:
  - "[[C 指针]]"
stategy:
  - "[[Dynamic Programming 动态规划]]"
timeComplexity:
  - O(n)
spaceComplexity:
  - O(n)
---

```embed
title: "01. 动态规划基础知识"
image: "https://algo.itcharge.cn/logo.svg"
description: "1. 动态规划简介 1.1 动态规划的定义 动态规划（Dynamic Programming）：简称 DP，是一种求解多阶段决策过程最优化问题的方法。在动态规划中，通过把原问题分解为相对简单的子问题，先求解子问题，再由子问题的解而得到原问题的解。 动态规划最早由理查德 · 贝尔曼于 1957 年在其著作「动态规划（Dynamic Programming…"
url: "https://algo.itcharge.cn/10.Dynamic-Programming/01.Dynamic-Programming-Basic/01.Dynamic-Programming-Basic/#_4-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"
```

## Introduction to Dynamic Programming 何为动态规划

### 动态规划的基本概念

**动态规划**（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。对于$O(2^n)$（指数时间）的问题，动态规划往往能将其转化为$O(n^k)$（多项式时间）的问题，大幅减少所需要的时间。 

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

> [!info]
> 动态规划保存递归时的结果，因而不会在解决同样的问题时花费不必要的时间

动态规划是一种利用[[Space–Time Trade Off 时空权衡|空间换时间]]的算法思路，通过将子问题的解存入缓存（cache）来避免重复计算
## When to use Dynamic Programming 何时使用动态规划
### 动态规划的适用范围

动态规划在查找有很多**重叠子问题**的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费不必要的时间。

动态规划只能应用于有**最优子结构**的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。

### 动态规划问题的基本特性

能够利用动态规划思路解决的问题都具有以下特质：

1. **最优子结构性质**：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（满足最优化原理）。<mark style="background: #FF5582A6;">最优子结构性质为动态规划算法解决问题提供了重要线索</mark>![[最优子结构示意图.png]]
2. **无后效性**：即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响
	
	举个例子，下图是一个有向无环带权图，我们在求解从 𝐴 点到 𝐹 点的最短路径问题时，假设当前已知从 𝐴 点到 𝐷 点的最短路径$（2+7=9）$。那么无论之后的路径如何选择，都不会影响之前从 𝐴 点到 𝐷 点的最短路径长度。这就是「无后效性」。![[无后效性示意图.png]]
	而如果一个问题具有「后效性」，则可能需要先将其转化或者逆向求解来消除后效性，然后才可以使用动态规划算法
	
1. **子问题重叠性质**：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是<mark style="background: #FFB86CA6;">利用了这种子问题的重叠性质</mark>，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度![[重叠子问题示意图.png]]

## Dynamic Programming Strategy 动态规划的基本思路

如下图所示，我们在使用动态规划方法解决某些最优化问题时，可以将解决问题的过程按照一定顺序（时间顺序、空间顺序或其他顺序）分解为若干个相互联系的「阶段」。然后按照顺序对每一个阶段做出「决策」，这个决策既决定了本阶段的效益，也决定了下一阶段的初始状态。依次做完每个阶段的决策之后，就得到了一个整个问题的决策序列。

这样就将一个原问题分解为了一系列的子问题，再通过逐步求解从而获得最终结果
![[动态规划思路图解.png]]
这种前后关联、具有链状结构的多阶段进行决策的问题也叫做「多阶段决策问题」。

通常我们使用动态规划方法来解决问题的基本思路如下：

1. **划分阶段**：将原问题按顺序（时间顺序、空间顺序或其他顺序）分解为若干个相互联系的「阶段」。划分后的阶段⼀定是有序或可排序的，否则问题⽆法求解。

> [!info]
> 这里的「阶段」指的是⼦问题的求解过程。每个⼦问题的求解过程都构成⼀个「阶段」，在完成前⼀阶段的求解后才会进⾏后⼀阶段的求解。

2. **定义状态**：将和子问题相关的某些变量（位置、数量、体积、空间等等）作为一个「状态」表示出来。状态的选择要满⾜⽆后效性。

> [!tip]
> 一个「状态」对应一个或多个子问题，所谓某个「状态」下的值，指的就是这个「状态」所对应的子问题的解。

3. **状态转移**：根据「上一阶段的状态」和「该状态下所能做出的决策」，推导出「下一阶段的状态」。或者说根据相邻两个阶段各个状态之间的关系，确定决策，然后推导出状态间的相互转移方式（即「状态转移方程」）。
4. **初始条件和边界条件**：根据问题描述、状态定义和状态转移方程，确定初始条件和边界条件。
5. **最终结果**：确定问题的求解目标，然后按照一定顺序求解每一个阶段的问题。最后根据状态转移方程的递推结果，确定最终结果。
## Practice Dynamic Programming 动态规划的实际运用

以下是一个对动态规划形象的比喻：

>[!example]
>- A ： "1+1+1+1+1+1+1+1 =？"
>- A ： "上面等式的值是多少"
>- B ： 计算 "8"
>- A : 在上面等式的左边写上 "1+" 呢？
>- A : "此时等式的值为多少"
>- B : 很快得出答案 "9"
>- A : "你怎么这么快就知道答案了"
>- A : "只要在8的基础上加1就行了"
>- A : "所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"

观察上面的例子，我们可以发现，能够递归解决的问题很多时候也符合动规的要求。这是因为递归分治的过程中不可避免的会基于已经计算过的子问题，并重新进行一次计算。而这些计算是可以省略的。

### 斐波那契数列
斐波那契数列的计算就是其中一个很好的例子：
**斐波那契数列**：数列由 $𝑓(0)=1,𝑓(1)=2f(0)=1,f(1)=2$ 开始，后面的每一项数字都是前面两项数字的和。也就是：

$$
f(n)= \begin{cases}0, n=0\\1, n=1\\n=
f(n-2)+f(n-1), n>1\end{cases}

$$

通过公式 $𝑓(𝑛)=𝑓(𝑛−2)+𝑓(𝑛−1)f(n)=f(n−2)+f(n−1)$，我们可以将原问题 $𝑓(𝑛)f(n)$ 递归地划分为 $𝑓(𝑛−2)f(n−2) 和 𝑓(𝑛−1)f(n−1)$ 这两个子问题。其对应的递归过程如下图所示：

![[重叠子问题示意图.png]]

从图中可以看出：如果使用传统递归算法计算 $𝑓(5)f(5)$，需要先计算 $𝑓(3)f(3)$ 和 $𝑓(4)f(4)$，而在计算 $𝑓(4)f(4)$ 时还需要计算 $𝑓(3)f(3)$，这样 $𝑓(3)f(3)$ 就进行了多次计算。同理 $𝑓(0)f(0)$、$𝑓(1)f(1)$、$𝑓(2)f(2)$ 都进行了多次计算，从而导致了重复计算问题。

为了避免重复计算，我们可以使用动态规划中的「表格处理方法」来处理。

这里我们使用「自底向上的递推方法」求解出子问题 $𝑓(𝑛−2)f(n−2)$ 和 $𝑓(𝑛−1)f(n−1)$ 的解，然后把结果存储在表格中，供随后的计算查询使用。具体过程如下：

1. 定义一个数组 𝑑𝑝，用于记录斐波那契数列中的值。
2. 初始化 `𝑑𝑝[0]=0,𝑑𝑝[1]=1dp[0]=0,dp[1]=1`。
3. 根据斐波那契数列的递推公式 $𝑓(𝑛)=𝑓(𝑛−1)+𝑓(𝑛−2)f(n)=f(n−1)+f(n−2)$，从 𝑑𝑝(2)开始递推计算斐波那契数列的每个数，直到计算出 𝑑𝑝(𝑛)
4. 最后返回 𝑑𝑝(𝑛) 即可得到第 𝑛 项斐波那契数。

具体代码如下：

```python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1

        dp = [0 for _ in range(n + 1)]
        dp[0] = 0
        dp[1] = 1

        for i in range(2, n + 1):
            dp[i] = dp[i - 2] + dp[i - 1]

        return dp[n]
```

