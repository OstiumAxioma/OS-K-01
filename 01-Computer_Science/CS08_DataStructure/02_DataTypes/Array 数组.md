---
Date: 2024-01-17
tags:
  - 计算机/数据结构
  - 计算机/编程语言
  - 计算机/数据结构/抽象类型
  - "#计算机/复杂度/时间复杂度"
  - 计算机
Component:
  - "[[C 数组]]"
TimeComplexity:
  - O(n)
SpaceComplexity:
  - O(n)
Status: true
---
## 数据结构简介
数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。下图展示了数组的主要概念和存储方式。

![[Pasted image 20240421232530.png|center|600]]
<center><sup>数组定义与存储方式</sup></center>

### 数据结构历史
第一台数字计算机使用机器语言编程来设置和访问资料表，向量和矩阵计算的数组结构，以及许多其它目的。1945年，在建立第一个范纽曼型架构计算机时，约翰·冯·诺伊曼（John von Neumann）写了第一个数组排序程序（合并排序）。数组索引最初是通过自修改代码，后来使用索引寄存器和间接寻址来完成的。1960年代设计的一些主机，如Burroughs B5000及其后继者，使用存储器分段来执行硬件中的索引边界检查。
### 解决的问题
数组是最早期和最重要的数据结构之一，很多程序都会用到数组。因为在程序运行时可以计算元素的索引，数组是很有用的。此外，也能以单一迭代语句就处理数组的许多元素。为此，数组数据结构的元素必须具有相同的大小，而且应该使用相同的资料类型表示。
### 解决思路
由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。
## 数据结构的实现

### 初始化/储存
我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 0 ：

```c
/* 初始化数组 */
int arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }
int nums[5] = { 1, 3, 2, 5, 4 };
```

#### 扩容数组
在复杂的系统环境中，程序难以保证数组之后的[[Memory 内存|内存空间]]是可用的，从而无法安全地扩展数组容量。

> [!warning]
> 在大多数编程语言中，**数组的长度是不可变的**。

如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 $𝑂(𝑛)$ 的操作，在数组很大的情况下非常耗时。代码如下所示：

```c
/* 扩展数组长度 */
int *extend(int *nums, int size, int enlarge) {
    // 初始化一个扩展长度后的数组
    int *res = (int *)malloc(sizeof(int) * (size + enlarge));
    // 将原数组中的所有元素复制到新数组
    for (int i = 0; i < size; i++) {
        res[i] = nums[i];
    }
    // 初始化扩展后的空间
    for (int i = size; i < size + enlarge; i++) {
        res[i] = 0;
    }
    // 返回扩展后的新数组
    return res;
}
```

普通数组采用一个整数来作下标。**多维数组**（**高维数组**）的概念特别是在数值计算和图形应用方面非常有用。我们在多维数组之中采用一系列有序的整数来标注，如在[ 3,1,5 ] 。这种整数列表之中整数的个数始终相同，且被称为数组的“维度”。关于每个数组维度的边界称为“维”。维度为_k_的数组通常被称为_k_维。

多维数组的数组名字，在表达式中自动转换为数组首元素地址值，但这个首元素实际上是去除数组下标第一维之后的数组剩余部分。例如：

```c
int a[10][15];
int (*p)[15] = a; // a在表达式中自动转换为指向具有15个int的数组的指针值
```

#### 多维数组

### 插入元素（增加）
数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如下图所示，如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引

![[Pasted image 20240421233128.png|center|600]]
<center><sup>数组插入元素示例</sup></center>
> [!important]
> 值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素“丢失”。

```c
/* 在数组的索引 index 处插入元素 num */
void insert(int *nums, int size, int num, int index) {
    // 把索引 index 以及之后的所有元素向后移动一位
    for (int i = size - 1; i > index; i--) {
        nums[i] = nums[i - 1];
    }
    // 将 num 赋给 index 处的元素
    nums[index] = num;
}
```
### 删除
同理，如图所示，若想删除索引 𝑖 处的元素，则需要把索引 𝑖 之后的元素都向前移动一位

![[Pasted image 20240422001417.png|center|600]]
<center><sup>数组删除元素示例</sup></center>
请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它

```c
/* 删除索引 index 处的元素 */
// 注意：stdio.h 占用了 remove 关键词
void removeItem(int *nums, int size, int index) {
    // 把索引 index 之后的所有元素向前移动一位
    for (int i = index; i < size - 1; i++) {
        nums[i] = nums[i + 1];
    }
}
```

### 访问
数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（首元素内存地址）和某个元素的索引，我们可以使用图 4-2 所示的公式计算得到该元素的内存地址，从而直接访问该元素。

![[Pasted image 20240421233000.png|center|600]]
<center><sup>数组元素的内存地址计算</sup></center>
观察上图，我们发现数组首个元素的索引为 0 ，这似乎有些反直觉，因为从 1 开始计数会更自然。但从地址计算公式的角度看，**索引本质上是内存地址的偏移量**。首个元素的地址偏移量是 0 ，因此它的索引为 0 是合理的

在数组中访问元素非常高效，我们可以在 𝑂(1) 时间内随机访问数组中的任意一个元素

```c
/* 随机访问元素 */
int randomAccess(int *nums, int size) {
    // 在区间 [0, size) 中随机抽取一个数字
    int randomIndex = rand() % size;
    // 获取并返回随机元素
    int randomNum = nums[randomIndex];
    return randomNum;
}
```

在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：

```c
/* 遍历数组 */
void traverse(int *nums, int size) {
    int count = 0;
    // 通过索引遍历数组
    for (int i = 0; i < size; i++) {
        count += nums[i];
    }
}
```

### 查找
在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。

因为数组是线性数据结构，所以上述查找操作被称为“线性查找”

```c
/* 在数组中查找指定元素 */
int find(int *nums, int size, int target) {
    for (int i = 0; i < size; i++) {
        if (nums[i] == target)
            return i;
    }
    return -1;
}
```
## 优势/局限性
数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。

- **空间效率高**：数组为数据分配了连续的内存块，无须额外的结构开销。
- **支持随机访问**：数组允许在 $𝑂(1)$ 时间内访问任何元素。
- **缓存局部性**：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。

连续空间存储是一把双刃剑，其存在以下局限性。

- **插入与删除效率低**：当数组中元素较多时，插入与删除操作需要移动大量的元素。
- **长度不可变**：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。
- **空间浪费**：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。
## 数据结构复杂度

### 时间复杂度
- **访问**：通过数组下标访问
	- $O(1)$，数组下标会直接给出元素位置
- **插入**：取决于插入元素的位置
	- $O(1)$，尾部插入不需要遍历数组只需要放入末尾<font color="#4bacc6">已经声明</font>的内存空间
	- $O(n)$，头部插入需要把整个数组后移一位
- **删除**：取决于需要删除的元素的位置
	- $O(1)$：尾部删除不需要遍历数组只需要清空末尾<font color="#4bacc6">已经声明</font>的内存空间
	- $O(n)$，头部删除<font color="#ff5e56">最差</font>需要把整个数组前移一位
- **查找**：寻找特定未知下标元素
	- $O(n)$，不知道下标的情况下需要遍历并对比整个数组
### 空间复杂度
- **储存**：取决于数组的维度，空间复杂度为$O(n^k)$，其中$n$是数组数据的数量，$k$是数组的维度
- **插入**：取决于插入元素的位置
	- $O(1)$，尾部插入不需要声明额外空间，只需要放入末尾<font color="#4bacc6">已经声明</font>的内存空间
	- $O(n)$，头部插入需要把整个数组后移一位，因此需要额外声明一个等长的数组来储存原有的数据
- **删除**：默认已经找到需要删除的元素
	- $O(1)$：删除指定下标<font color="#4bacc6">已经声明</font>的内存空间
- **查找**：寻找特定未知下标元素
	- $O(1)$，只需要声明常数级别的变量在遍历数组过程中进行对比
## 数据结构使用实例
数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。

- **随机访问**：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。
- **排序和搜索**：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。
- **查找表**：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。
- **机器学习**：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。
- **数据结构实现**：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，[[图的邻接矩阵]]表示实际上是一个二维数组。