---
Date: 2024-01-20
tags:
  - 计算机/编程语言/C
  - 计算机/数据结构
  - 计算机
  - 计算机/编程语言
Type:
  - Lecture
Year:
  - 2024 Spring
---
# 时间复杂度基础

运行时间可以直观且准确地反映算法的效率。如果我们想准确预估一段代码的运行时间，应该如何操作呢？

1. **确定运行平台**，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。
2. **评估各种计算操作所需的运行时间**，例如加法操作 `+` 需要 1 ns ，乘法操作 `*` 需要 10 ns ，打印操作 `print()` 需要 5 ns 等。
3. **统计代码中所有的计算操作**，并将所有操作的执行时间求和，从而得到运行时间。

例如在以下代码中，输入数据大小为 𝑛 ：

```c
// 在某运行平台下
void algorithm(int n) {
    int a = 2;  // 1 ns
    a = a + 1;  // 1 ns
    a = a * 2;  // 10 ns
    // 循环 n 次
    for (int i = 0; i < n; i++) {   // 1 ns ，每轮都要执行 i++
        printf("%d", 0);            // 5 ns
    }
}
```


根据以上方法，可以得到算法的运行时间为 $(6𝑛+12)$ ns ：

$$1+1+10+(1+5)×𝑛=6𝑛+12$$

但实际上，**统计算法的运行时间既不合理也不现实**。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。

## 统计时间增长趋势

时间复杂度分析统计的不是算法运行时间，**而是算法运行时间随着数据量变大时的增长趋势**。

“时间增长趋势”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 𝑛 ，给定三个算法 `A`、`B` 和 `C` ：

```c
// 算法 A 的时间复杂度：常数阶
void algorithm_A(int n) {
    printf("%d", 0);
}
// 算法 B 的时间复杂度：线性阶
void algorithm_B(int n) {
    for (int i = 0; i < n; i++) {
        printf("%d", 0);
    }
}
// 算法 C 的时间复杂度：常数阶
void algorithm_C(int n) {
    for (int i = 0; i < 1000000; i++) {
        printf("%d", 0);
    }
}
```

图 2-7 展示了以上三个算法函数的时间复杂度。

- 算法 `A` 只有 1 个打印操作，算法运行时间不随着 𝑛 增大而增长。我们称此算法的时间复杂度为“常数阶”。
- 算法 `B` 中的打印操作需要循环 𝑛 次，算法运行时间随着 𝑛 增大呈线性增长。此算法的时间复杂度被称为“线性阶”。
- 算法 `C` 中的打印操作需要循环 1000000 次，虽然运行时间很长，但它与输入数据大小 𝑛 无关。因此 `C` 的时间复杂度和 `A` 相同，仍为“常数阶”。

![[复杂度级别关系.png| center | 500]]

相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？

- **时间复杂度能够有效评估算法效率**。例如，算法 `B` 的运行时间呈线性增长，在 𝑛>1 时比算法 `A` 更慢，在 $𝑛>1000000$ 时比算法 `C` 更慢。事实上，只要输入数据大小 𝑛 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是<mark class="hltr-blue">时间增长趋势</mark>的含义。
- **时间复杂度的推算方法更简便**。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。
- **时间复杂度也存在一定的局限性**。例如，尽管算法 `A` 和 `C` 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 `B` 的时间复杂度比 `C` 高，但在输入数据大小 𝑛 较小时，算法 `B` 明显优于算法 `C` 。在这些情况下，我们很难仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。

## 函数渐近上界

给定一个输入大小为 𝑛 的函数：

```c
void algorithm(int n) {
    int a = 1;  // +1
    a = a + 1;  // +1
    a = a * 2;  // +1
    // 循环 n 次
    for (int i = 0; i < n; i++) {   // +1（每轮都执行 i ++）
        printf("%d", 0);            // +1
    }
}
```

设算法的操作数量是一个关于输入数据大小 𝑛 的函数，记为 𝑇(𝑛) ，则以上函数的操作数量为：

$$𝑇(𝑛)=3+2𝑛$$

𝑇(𝑛) 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。

我们将线性阶的时间复杂度记为 $𝑂(𝑛)$ ，这个数学符号称为大 𝑂 记号（big-𝑂 notation），表示函数 $𝑇(𝑛)$ 的渐近上界（asymptotic upper bound）。

时间复杂度分析本质上是计算“<mark class="hltr-cyan">操作数量</mark> $𝑇(𝑛)$”的渐近上界，它具有明确的数学定义。

> [!info]
> 若存在正实数 𝑐 和实数 𝑛0 ，使得对于所有的 𝑛>𝑛0 ，均有 𝑇(𝑛)≤𝑐⋅𝑓(𝑛) ，则可认为 𝑓(𝑛) 给出了 𝑇(𝑛) 的一个渐近上界，记为 𝑇(𝑛)=𝑂(𝑓(𝑛)) 。

如图 2-8 所示，计算渐近上界就是寻找一个函数 $𝑓(𝑛)$ ，使得当 𝑛 趋向于无穷大时，$𝑇(𝑛)$ 和 $𝑓(𝑛)$ 处于相同的增长级别，仅相差一个常数项 $𝑐$ 的倍数。

![[计算渐进上界.png| center | 500]]

## 推算方法

渐近上界的数学味儿有点重，如果你感觉没有完全理解，也无须担心。我们可以先掌握推算方法，在不断的实践中，就可以逐渐领悟其数学意义。

根据定义，确定 $𝑓(𝑛)$ 之后，我们便可得到时间复杂度 $𝑂(𝑓(𝑛))$ 。那么如何确定**渐近上界** $𝑓(𝑛)$ 呢？总体分为两步：首先统计操作数量，然后判断渐近上界。

### 第一步：统计操作数量

针对代码，逐行从上到下计算即可。然而，由于上述 $𝑐⋅𝑓(𝑛)$ 中的常数项 𝑐 可以取任意大小，**因此操作数量 $𝑇(𝑛)$ 中的各种系数、常数项都可以忽略**。根据此原则，可以总结出以下计数简化技巧。

1. **<font color="#ff5e56">忽略 𝑇(𝑛) 中的常数项</font>**：因为它们都与 𝑛 无关，所以对时间复杂度不产生影响。
2. **<font color="#ff5e56">省略所有系数</font>**：例如，循环 2𝑛 次、5𝑛+1 次等，都可以简化记为 𝑛 次，因为 𝑛 前面的系数对时间复杂度没有影响。
3. **<font color="#ff5e56">循环嵌套时使用乘法</font>**：总操作数量等于外层[[Iteration and Recursion 迭代与递归|循环]]和内层循环操作数量之积，每一层循环依然可以分别套用第 `1.` 点和第 `2.` 点的技巧。

给定一个函数，我们可以用上述技巧来统计操作数量：

```c
void algorithm(int n) {
    int a = 1;  // +0（技巧 1）
    a = a + n;  // +0（技巧 1）
    // +n（技巧 2）
    for (int i = 0; i < 5 * n + 1; i++) {
        printf("%d", 0);
    }
    // +n*n（技巧 3）
    for (int i = 0; i < 2 * n; i++) {
        for (int j = 0; j < n + 1; j++) {
            printf("%d", 0);
        }
    }
}
```

以下公式展示了使用上述技巧前后的统计结果，两者推算出的时间复杂度都为 𝑂(𝑛2) 。

$T(n) = 2n(n+1)+(5n+1)+2$
    $= 2n^2+7n+3$
$T(n) = n^2+n$

### 第二步：判断渐近上界

**时间复杂度由 𝑇(𝑛) 中最高阶的项来决定**。这是因为在 𝑛 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。

下表展示了一些例子，其中一些夸张的值是为了强调“系数无法撼动阶数”这一结论。当 𝑛 趋于无穷大时，这些常数变得无足轻重。

不同操作数量对应的时间复杂度

| 操作数量 𝑇(𝑛)      | 时间复杂度 𝑂(𝑓(𝑛)) |
| ---------------- | ---------------- |
| $100000$           | $𝑂(1)$            |
| $3𝑛+2$            | $𝑂(𝑛)$           |
| $2𝑛^2+3𝑛+2$       | $𝑂(𝑛^2)$          |
| $𝑛^3+10000𝑛2$     | $𝑂(𝑛^3)$          |
| $2^𝑛+10000𝑛^10000$ | $𝑂(2^𝑛)$          |

## 2.3.4   常见类型

设输入数据大小为 𝑛 ，常见的时间复杂度类型如下所示（按照从低到高的顺序排列）。

$$O(1)<O(\log_{}{n})<O(n)<O(n\log_{}{n})<O(n^2)<O(2^n)<O(n!)$$
分别对应：
<center>常数阶<对数阶<线性阶<线性对数阶<平方阶<指数阶<阶乘阶</center>

![[Pasted image 20240419145129.png|center|500]]

### 常数阶$𝑂(1)$
常数阶的操作数量与输入数据大小 𝑛 无关，即不随着 𝑛 的变化而变化。

在以下函数中，尽管操作数量 `size` 可能很大，但由于其与输入数据大小 𝑛 无关，因此时间复杂度仍为 $𝑂(1)$ ：

```c
/* 常数阶 */
int constant(int n) {
    int count = 0;
    int size = 100000;
    int i = 0;
    for (int i = 0; i < size; i++) {
        count++;
    }
    return count;
}
```

### 线性阶$𝑂(n)$
线性阶的操作数量相对于输入数据大小 𝑛 以线性级别增长。线性阶通常出现在单层循环中：

```c
/* 线性阶 */
int linear(int n) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        count++;
    }
    return count;
}
```

遍历数组和遍历链表等操作的时间复杂度均为 $𝑂(𝑛)$ ，其中 𝑛 为数组或链表的长度：